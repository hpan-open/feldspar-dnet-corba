;;;; lexer-generator, generate lexers from regular expressions;(eval-when (load compile eval);  (unless (find-package :scanner-generator);    (make-package :scanner-generator)));;(in-package :scanner-generator)(use-package :nfa-compiler);(defpackage :lexer-generator;  (:use :common-lisp :nfa-compiler);  (:export :lexer-spec->table+actions :make-string-nexter :next-token));;(in-package :lexer-generator)(defconstant *char-code-limit* 256)(defun add-other-case (l)  (let ((ans nil))    (dolist (c l)      (if (alpha-char-p c)	  (progn	    (push (char-upcase c) ans)	    (push (char-downcase c) ans))	(push c ans)))    ans));;;; subnfa = Sub-Nondeterminitic-Finite-Automaton(defun cset-subnfa (nfa str ign-case)  (let ((l (coerce str 'list  )))  (subnfa-simple nfa (mapcar #'char-code		       (if ign-case			   (add-other-case l)			   l)))))(defun string-subnfa (nfa str ign-case)  (subnfa-append nfa (mapcar		      #'(lambda (c) (subnfa-simple nfa						 (if (and ign-case (alpha-char-p c))						     (list (char-code (char-upcase c))							   (char-code (char-downcase c)))						   (list (char-code c)))))		      (coerce str 'list))))(defun not-cset-subnfa (nfa args ign-case)  (let* ((str (apply #'concatenate 'string (mapcar #'(lambda (x) (if (stringp x) x (string x))) args)))	 (li (mapcar #'char-code		  (if ign-case		      (add-other-case (coerce str 'list))		      (coerce str 'list)))))    (do ((i 0 (1+ i)) (l '() (if (member i li) l (cons i l))))	((= i *char-code-limit*) 	 (subnfa-simple nfa l)))))(defun sym= (sym1 sym2)  (and (symbolp sym1) (symbolp sym2)       (string= (string sym1) (string sym2))))(defun sexp->subnfa (nfa sexp ign-case)    (cond    ((stringp sexp) (string-subnfa nfa sexp ign-case))   ((characterp sexp) (cset-subnfa  nfa (string sexp) ign-case))   ((sym= sexp 'digit) (cset-subnfa nfa "0123456789" nil))   ((sym= sexp 'alpha) (cset-subnfa nfa  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" nil))   ((sym= sexp 'alpha-num) (cset-subnfa  nfa  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" nil))   ((sym= sexp 'oct-digit) (cset-subnfa  nfa "01234567" nil))   ((sym= sexp 'hex-digit) (cset-subnfa nfa "0123456789abcdefABCDEF" nil))   ((sym= sexp 'space) (cset-subnfa nfa " " nil))   ((sym= sexp 'ws) (subnfa-+ nfa (cset-subnfa nfa " " nil)))   (t    (let ((c (car sexp)))            (if (stringp c)	  (cset-subnfa nfa c ign-case)	  (cond 	    ((sym= c 'case) (sexp->subnfa nfa (cadr sexp) nil))	    ((sym= c 'ign-case) (sexp->subnfa nfa (cadr sexp) t))	    ((sym= c '^) (not-cset-subnfa nfa (cdr sexp) ign-case))	    ((sym= c 'or) (subnfa-or nfa (mapcar #'(lambda (x) (sexp->subnfa nfa x ign-case)) (cdr sexp))))	    (t	    (let ((r (subnfa-append nfa (mapcar #'(lambda (x) (sexp->subnfa nfa x ign-case)) (cdr sexp)))))	     	      (cond 		((sym= c '*) (subnfa-* nfa r))		((sym= c '+) (subnfa-+ nfa r))		((sym= c 'seq) r)		((sym= c '?) (subnfa-? nfa r))		(t (error "not avalid srex" sexp)))))))))));;----------------------------------------------------------------------------------------;; states is the stuff returned by nfa->dfa(defun make-dfa-table (states start tokens)  (flet  ((state->token (s)		       (let ((state-list (aref (aref states s) 1)))			 (when (null state-list) (return-from state->token nil))			 (dolist (tok tokens)			   (when (member (car tok) state-list)			     (return-from state->token (cdr tok))))			 nil)))	    (let ((table (make-array (length states))))      (do ((i 0 (1+ i)))	  ((= i (length states)) table)	(let* ((s (aref states i))	       (trs (mapcar #'(lambda (tr) (vector (aref tr 0) (aref tr 1) (state->token (aref tr 1)))) (aref s 2))))	  (setf (aref table i) trs))))));; l is a list of (cons symbolic-regular-expression some-value) ;;(defun lexer-spec->dfa-table (l ign-case)  (let ((nfa (make-nfa *char-code-limit*))	(la '())	(tokens '()))    (dolist (x l)      (let ((a (sexp->subnfa nfa (car x) ign-case))	    (tok (cdr x))) ; t the token	(push a la)	(push  (cons (subnfa-end a) tok) tokens)))        (let ((a (subnfa-or nfa la)))      (multiple-value-bind (dfa  starts) (nfa->dfa nfa (list (subnfa-start a)) (mapcar #'car tokens))	(make-dfa-table dfa starts (reverse tokens))))))(defun list->bitvector (l size)  (let ((v (make-array size :element-type 'bit :initial-element 0)))    (dolist (i l) (setf (sbit v i) 1))    v))(defun list->integer (l)  (let ((i 0))    (dolist (x l) (setf i (logior i (ash 1 x))))    i))(defun transform (l)  (mapcar #'(lambda (ta) (vector (list->bitvector (aref ta 0) 256)  (aref ta 1))) l))    (defun lexer-spec->table+actions (spec ign-case)    (let ((nfa (make-nfa *char-code-limit*))	(v-action (make-array (length spec)))  ; the actions tokens....	(m-state (make-hash-table :test 'equal))) ; the mapping from nfa-state-number to the index in v-action        (multiple-value-bind  ; first part, compute the the dfa table, mapping number->action, mapping  	(dfa starts) 	(do ((i 0 (1+ i)) (l spec (cdr l)) (la '() la))	     ((null l)		 (let ((a (subnfa-or nfa la)))		   (nfa->dfa nfa (list (subnfa-start a)) (mapcar #'subnfa-end la))))	       (let ((a (sexp->subnfa nfa (caar l) ign-case))		     (ac (cdar l))) ; ac the action		 (if (and (or (not (car ac)) (symbolp (car ac))) (= 1 (length ac)))		     (setf ac (car ac))		   (setf ac (list 'function (append '(lambda (str)) ac)))) 		 (setf (aref v-action i) ac)		 (setf  (gethash (subnfa-end a) m-state ) i)		 (push a la)))          (let ((tab (make-array (length dfa)))	    (state-list->num  ; from alist of states, find the state which comes first in the lexer spec 	     #'(lambda (li)	       (and li		    (let ((no (gethash (car li)     m-state)))		      (dolist (x (cdr li))			(setf no  (min no (gethash x m-state))))		      no)))))			 		; build the final table, the format is: #(   #(action-number (transition1 transition2 .........)) .......................	(do ((i 0 (1+ i)))	    ((= i (length tab)) (values (car starts) tab v-action))   ; we are done, return the table and the actions	  (let ((entry (aref dfa i)))	    (setf (aref tab i)		  (vector (funcall state-list->num (aref entry 1))  ; the action, if any				  			  (transform (aref entry 2))))))))));; the support functions(defun generate-to-stream (token-list case s)  (multiple-value-bind (start ta ac) (lexer-spec->table+actions token-list case)    	  (pprint '(defvar *action*) s)	  (pprint '(defvar *start*) s)	  (pprint '(defvar *table*) s)	  (pprint `(setf *table* ',ta) s)	  ;(pprint `(setf *action* ,(cons 'vector (map 'list #'(lambda (x) (if (symbolp x) (list 'quote x) x)) ac))) s)	  (pprint `(setf *start* ,start) s)	  (pprint `(setf *action* (make-array ,(length ac) :adjustable nil :fill-pointer nil)) s)	  (do ((i 0 (1+ i))) ((= i (length ac)))	    (pprint `(setf (aref *action* ,i)			   ,(let ((x (aref ac i)))			      (if (symbolp x) (list 'quote x) x)))		    s))));(export '(lexer-spec->table+actions generate-to-stream))