;;;  (make-package :scanner-support);;;  (in-package :scanner-support)(defun make-string-nexter (str)  (let ((len (length str)))    #'(lambda (i)      (if (= i len)	  (values nil i)	  (values (char str i) (1+ i)))))); the position is the list(defun list-nexter (l)  (if (null l)      (values nil l)    (values (car l) (cdr l)))); input is a character(defun stream-nexter (pos)  (cond    ((streamp (cdr pos))    (let ((c (read-char (cdr pos) nil nil nil)))      (setf (cdr pos) (cons c (cdr pos)))      (values c (if c (cdr pos) nil))))   ((null (cdr pos))    (values nil nil))   (t (values (cadr pos) (cdr pos)))))(defun make-stream-pos (s)  (cons nil s));; always seek (defun make-file-stream-nexter (stream)  #'(lambda (pos)      (file-position stream pos)      (let ((c (read-char stream nil nil nil)))	(values c (1+ pos)))));;;;;;----------------------------------------------------------------------------------------------------------;;  a stream for a port, takes care of the position and backing up;; a lexer stream is a position in stream (defstruct (lexer-stream (:constructor internal-make-lexer-stream))   stream char line column count next)(defun make-lexer-stream (stream)  (internal-make-lexer-stream :stream stream :char #\a :line 0 :column 0 :count 0 :next nil))(defun next-position (pos)  (cond    ((null (lexer-stream-char pos))  (values nil nil))  ; eof alread read   ((not (lexer-stream-next pos))    (let* ((c (read-char (lexer-stream-stream pos) nil nil nil))	   (newpos (if (null c) 		       (internal-make-lexer-stream			:stream (lexer-stream-stream pos)			:char nil			:line (lexer-stream-line pos)			:column (lexer-stream-column pos)			:count (lexer-stream-count pos)			:next nil)		     (internal-make-lexer-stream		      :stream (lexer-stream-stream pos)		      :char c		      :line (if (char= c #\newline) (1+ (lexer-stream-line pos)) (lexer-stream-line pos))		      :column (if  (char= c #\newline) 0  (1+ (lexer-stream-column pos)))		      :count (1+ (lexer-stream-count pos))		      :next nil))))      (setf (lexer-stream-next pos) newpos)      (values c newpos)))   (t (values (lexer-stream-char (lexer-stream-next pos)) (lexer-stream-next pos)))));;; -----------------------------------------------------------------------------------------------------------(defun dfa-step (table state input)  (let ((ch (char-code input)))    (dolist (trans (aref (svref table state) 1))      (when (= 1 (sbit  (svref trans 0) ch))	(let ((newstate (svref trans 1)))	  (return-from dfa-step (values newstate (svref (svref table newstate) 0))))))    (values nil nil)))(defun next-token (table start next-pos-proc first-pos)      (let ((state start)   ; the state of the automaton	  (pos first-pos) ; the current position	  (acu '())       ; the acumulated characters	  (last-token nil)    ; the last regocnized token	  (last-token-pos nil) ; the position after this token	  (last-token-acu '())) ; the acumulator for this last token      (loop 	(multiple-value-bind (c next-pos) (funcall next-pos-proc pos)	  (unless c                         ; eof encountered i.e. nil	    (return-from next-token 	      (if last-token		  (values last-token (coerce (reverse last-token-acu) 'string) last-token-pos) ; return the last read token, its string, and then position after it		(if (null acu)          		    (values c nil pos)     ; this is the real end , return the eof-object		  (values nil (string (car (reverse acu))) (funcall next-pos-proc first-pos))))))    ; no token found return the character and advanve one character	  	  (multiple-value-bind (newstate token) (dfa-step table state c)	    (if newstate		(progn		  (setf state newstate)		  (push c acu)		  (setf pos next-pos)		  (when token		    (setf last-token token)		    (setf last-token-pos next-pos)		    (setf last-token-acu  acu)))	      (return-from next-token		(if last-token		    (values last-token (coerce (reverse last-token-acu) 'string) last-token-pos)   ; return the last found token, its string					;and the position after it		  (multiple-value-bind (c p) (funcall next-pos-proc first-pos)		    (values nil (string c) p))))))))))					; nothing found: return #f, the string found and the next position; read the next character from buffer, position must not be larger than the fill-pointer; if theere no more chars in buffer the result of the call to next-proc is appended to the buffer(defun get-char (buffer pos next-proc)  (cond   ((= pos (fill-pointer buffer)) ; are there chars in the buffer left?    (do ((c (funcall next-proc) (funcall next-proc)))  ;; string length might be 0, so we have to loop, or should "" raise an error?	((or (not c) (characterp c) (and (stringp c) (not (zerop (length c)))))	 (and c	      (progn		(append-to-buffer buffer c)		  (aref buffer pos))))))   ((< pos (fill-pointer buffer))    (aref buffer pos))   (t (error "position to large when getting char from a buffer")))); take the first pos characters from buffer and return them; change the buffer!(defun take-from-buffer (buffer pos)  (prog1      (coerce (subseq buffer 0 pos) 'string)    (replace buffer buffer :start2 pos :end2 (fill-pointer buffer))    (setf (fill-pointer buffer) (- (fill-pointer buffer) pos)))); appends a string or a character to an adjustable array with fill-pointer(defun append-to-buffer (buffer c)  (if (characterp c)      (vector-push-extend c buffer)    (let ((fp (fill-pointer buffer)))	  (when (> (+ fp (length c)) (car (array-dimensions buffer)))	    (adjust-array buffer (+ fp (length c))))	  (setf (fill-pointer buffer) (+ fp (length c)))	  (replace buffer c :start1 fp)))); bla(defun make-scanner (table action-table start-state nexter)  (let ((buffer (make-array 0 :element-type 'char :adjustable t :fill-pointer t))	(position 0))    (labels	((next-token  ; the main procedure crank the aotomaton	  ()	  (let ((last-token nil)		(last-token-pos nil)		(i 0)		(state start-state)		(token nil)		(c))	    (loop	      (setf c (get-char buffer i nexter))	      ;(pprint c)	      (if c		  (progn		    (incf i)		    (multiple-value-setq (state token) (dfa-step table state c))		    ;(pprint (list '++++ state token))		    (if state   ; continue			(when token			  (setf last-token token)			  (setf last-token-pos i))		      (return-from next-token			(if last-token			    (values last-token (take-from-buffer buffer last-token-pos))			  (values nil (take-from-buffer buffer 1)))))) ; return as string the first read char					;EOF		(return-from next-token		  (if last-token		      (values last-token (take-from-buffer buffer last-token-pos))		    (if (= i 0) (values nil nil)		      (values nil (take-from-buffer buffer 1)))))))))	  	 (compute-token (token str) ; given a token, lookup it up in action-table and perform the action			(let ((x (svref action-table token)))			  (if x 			      (if (symbolp x)				  (cons x str)				(funcall  x str))			    nil)))	 	 (tokenizer ()      		    (loop		      (multiple-value-bind		       (token str) (next-token)		       ;(pprint (list '***** token  str))		       (unless (or token str) (return-from tokenizer nil)) ; EOF --> return nil		       (unless token (return-from tokenizer (cons nil str))) ; no token found			  (let ((x (compute-token token str)))  ; compute the token action			    (if x (return-from  tokenizer x))			    )))))  ; if not x then loop again      #'tokenizer)))(defun make-char-reader (stream)  (lambda () (read stream nil nil nil)))(defun make-line-reader (stream)  (lambda () (let ((l (read-line stream nil nil nil)))	       (and l (concatenate 'string l (string #\newline))))))(defmacro line-reader (stream &optional line-counter)  (let ((temp (gensym))	(stream-temp (gensym)))    `(let ((,stream-temp ,stream))       (lambda () (let ((,temp (read-line ,stream-temp nil nil nil)))		    (and ,temp ,(if line-counter				    `(progn (incf ,line-counter) (concatenate 'string ,temp (string #\newline)))				  `(concatenate 'string ,temp (string #\newline)))))))))          				              ;(export '(lexer-spec->table+actions make-string-nexter next-token));(make-array 'schar )