;;; idef-macros --- interface definition macros
;; $Id: idef-macros.lisp,v 1.6 2002/10/28 18:39:00 lenst Exp $

(in-package :clorb)


;;;; A Global Repository

(defvar *idef-repository*
    (make-instance 'repository))

(pushnew '*idef-repository* *repositories*)

(defun lookup-name (name)
  (lookup-name-in *idef-repository* name))

(defmethod gen-idef ((name string))
  (gen-idef (lookup-name name)))


;;;; Macro for IDEF definitions

(defmacro idef-definitions (&body forms)
  `(idef-read ',forms *idef-repository*))

(defmacro idef-code (&body forms)
  (let ((repository (make-instance 'repository)))
    (idef-read forms repository)
    (let* ((target (make-instance 'code-target))
           (stub (target-code repository target))
           (skel (target-servant repository target)))
      (make-progn
       (list (make-progn
              (loop for package in (slot-value target 'packages)
                    unless (member package *stub-code-ignored-packages*)
                    collect (make-target-ensure-package package target)))
             stub
             skel)))))
      

;;;; Creating a servant class

(defmacro define-servant (name scoped-name &key id)
  "Creates an auto-servant class for an interface.
This class can be used almost as a skeleton class generated by an
IDL-compiler."
  `(progn
     (defclass ,name (auto-servant)
       ())
     ,@(if id 
           `((defmethod servant-interface-id ((servant ,name))
              ,id)))
     (defmethod servant-interface ((servant ,name))
       (or (ignore-errors (lookup-name ,scoped-name))
           (call-next-method)))))


(defmacro require-idl (name &key file)
  `(eval-when (:load-toplevel :execute)
     (unless (lookup-name-in *idef-repository* ,name nil)
       (load ,file))))
