[NOTE: This READ ME is out of date.]


                                CLORB

                a Common Lisp implementation of CORBA

                    Version 0.3+ (an ALPHA release)

                          by Lennart Staflin



CLORB is an Object Request Broker implementing CORBA 2. It currently
supports DII, DSI and the POA. The goal is to make the mapping follow
the proposed mapping for LISP.

It lacks:

   * Support for some basic types (fixed) (still :-)
   * Support for value types

CLORB is released under GNU Library General Public License see the
file COPYING.


Ports:

   MCL 5        only tested with Max OS X
   OpenMCL      seems to work
   CMUCL        partially working (some test cases fail)
   SBCL         minimal test on Mac OS X
   ACL 6.2      seems to work, but the trial version can't compile the IDL
                compiler due to heap limitation
   --
   CLISP        not currently working, you could try CVS tag CLISP_OK





                                MCL 5

MCL 5.0 is the current main development environment. I also use the
BSD package [find good reference]. The networking code can either use
OpenTransport directly or use the ACL-COMPAT code from portable
allegro server [fix reference].

The file clmcl.lisp is what I have used during development to load
the system.

I use some extra features:

  use-acl-socket  --  to use the socket code from acl-compat

  use-my-idlparser  --  to also compile an alternative idl-compiler



                         About the CMUCL port

From: Daniel Barlow <dan@telent.net>
Date: 11 May 2000 00:39:38 +0100

[...]

2) The user has a choice of socket libraries: the standard CMUCL
socket code, or my replacement sockets library.  The standard code
doesn't support the socket option SO_REUSEADDR (without writing ffi
glue) so you need my sockets if you want to do server applications.
You can get it at http://ww.telent.net/lisp/sockets.html

3) The system is built using mk-defsystem, which comes with CMUCL
(if you use the Debian packages, at any rate).

4) Only tested on ix86 GNU/Linux so far.

5) It works, kind of.  It's not been extensively tested.  I can make
it talk as a client to the GNOME Help viewer (see
http://ww.telent.net/corba/gnome-lisp.html for a worked example), and
I can make the ORBit 'name-client' test program talk to your CosNaming
service implementation.  Serving is a bit CPU-intensive until I get it
actually blocking instead of busy-waiting when waiting for a connection.

6) It's not been tested recently in SBCL (Steel Bank Common Lisp) but
there's no particularly good reason for it not to work there too.
You'll have to use my socket library in that one, because it doesn't
have any socket code of its own at all.

[...]

                       About the included files

clorb-*.lisp

        This is main part of the ORB.

clorb-options.lisp

        Some parameters that might need to be customized. Especially
        host-name and how to find the Naming Service and Interface
        Repository.

socket.lisp

        System dependent code for socket handling.

clorb-sysdcl.lisp

        Is a defsystem declaration for ACL's defsystem.

        Note: It uses the logical pathname "devl:". I use that defined as
             "devl"      '(";**;*.fasl"  #p"bin/") '(";**;*.*" #p"./")
        to get fasl files in a subdirectory.

clorb.system

        Is a system declaration for mk-defsystem.

ns-server.lisp

        An implementation of CosNaming

pns-server.lisp

        A new implementation of CosNaming, where the state is stored
        in files (thus persistent).

ec-server.lisp

        An implementation CosEventChannel

dumpir.lisp

        Code to save and restore the internal cache of the Interface
        Repository objects. The file ir.dump is the saved cache. If
        you don't have a Interface Repository running, you could try
        loading this dump (with load-ir).

local-ir.lisp

        Interface Repository implementation. Mainly for use when
        generating code. (Code generation is currently only
        experimental). All Interface Repository objects can also
        be CORBA objects this can be used by servants to tell clients
        about their interface.

idef-read.lisp
idef-write.lisp

        Read and write IDEF, an sexp version of IDL. These reads and
        writes from the local Interface Repository implemention.

idef-macros.lisp
        Macro wrapper around idef-read to allow IDEF to be loaded from
        file. Also macro for defining servant skeleton class for use
        with the CLORB auto-servant class.

cosevent-idl.lisp
cosnaming-idl.lisp

        IDEF version of standard IDL for CosEventChannel and
        CosNaming. (generated by idef-write)

cosnaming-stub.lisp

        The types, classes for CosNaming according to the OMG Lisp Mapping.
        Proxy classes and operation methods.
        (This partly hand created static stub.)

cosnaming-skel.lisp

        Servant classes for CosNaming.


        (TEMPORARY until I have organized it better)

orb-export.lisp

        Export the interface repository symbols from the CORBA package.

orb-structs.lisp

        The interface repository structures correctly defined
        according to the OMG Lisp Mapping.

orb-stub.lisp

        All interface repository types and proxies.
        (mostly generated with gen-code)

orb-idl.lisp

        IDEF version of the interface repository IDL.


        EXAMPLE CODE

hello.idl
hello-idl.lisp

        Hello world interface definition.

hello-client.lisp

        Hello World client

hello-server.lisp
hello-dynserver.lisp

        Hello World server, auto-servant version and DSI version.


dii-example.lisp dsi-example.lisp clive.lisp

        Example of using DSI (dynamic servant implementation) and DII
        (dynamic invokation interface) using standard interfaces.
        From a discussion on comp.lang.corba

ec-factory-idl.lisp
ec-factory-impl.lisp

        Example of using the macros from idef-macros to define an
        interface and then to implement it. The interface is to a
        Factory object to create Event Channel objects using the
        ec-server implementation.

orbit.lisp

        Set *principal* for communication with ORBit (GNOME) servers.


        EXPERIMENTAL CODE

code-gen.lisp

        Generate code from interface repository.
        Ex: (load "cosnaming-idl.lisp")
            (eval (gen-code "CosNaming"))
        defines (client) classes and stub-operations for the CosNaming
        module.

internalize.lisp

        create local copy of interface repository objects


        BOOTSTRAP

loadup.lisp

        Load IIR cache from an external interface repository

make-proxies.lisp

        Create stub code for all external symbols in the OP package.

extract-ops.lisp



        TEST CASES

test-suite.lisp
test-marshal.lisp
test-idef-read.lisp
test-intern.lisp




                           Examples of use

Examples of creating server objects can be found in ns-server.lisp and
ec-server.lisp.

Using the client functionallity is easy if you have an Interface
Repository and a Naming Service.

The file clorb-util.lisp defines some convenience functions:

    (clorb:invoke OBJECT OPERATION &rest ARGS)  => RESULTS
or: (corba:funcall OPERATION OBJECT &rest ARGS) => RESULTS

          Call OPERATION on OBJECT with argument ARGS.
           OBJECT -- a CORBA object
           OPERATION -- a string
           ARGS -- all IN and INOUT arguments to the operation
           RESULTS -- the result and all OUT and INOUT arguments

  (clorb:resolve &rest NAMES)
           Look up NAMES in the naming service.


Example: Calling the list operation on the root NamingContext

    (let* ((orb (corba:orb_init))
           (ns  (op:resolve_initial_references orb "NameService")))
      (corba:funcall "list" ns 100))


There is a hello world example included.The interface is defined in
'hello.idl' (the file 'hello-idl.lisp' can be used to load the local
Interface Repository, if you don't have a Interface Repository
running). The server is defined in 'hello-server.lisp', this uses the
CLORB specific auto-servant. There is a server using DSI in
'hello-dynserver.lisp', this used only standard interfaces. The client
is in 'hello-client.lisp'.

The server can be started with (run-hello &key file name). The
argument is where to store the object reference, to a file or in the
name service (you need one running).

Example (this should work with ACL, CLISP and CMUCL):

> Common startup

;; Load CLORB
;; using ACL defsystem
 (load "clorb-sysdcl")
 (excl:load-system :clorb :compile t)
;; or  Mkdefsys
  (make:oos :clorb :compile)

;; If you don't have a ir (or even if you do), load the internal ir cache
 (clorb::load-ir)


> Running the server:

 (load "hello-idl.lisp")   ;; or feed hello.idl to the interface repository
 (run-hello :file "/tmp/hej")


> Running the client:

 (hello-client :file "/tmp/hej")
"Hello World"

